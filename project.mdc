---
alwaysApply: true
---

1. 프로젝트 개요 및 아키텍처
   1.1. 시스템 개요  
   목표: 원격제어장치(RCS)에 연결된 4개의 장비 전원을 웹 인터페이스를 통해 개별/일괄 제어 및 상태 모니터링.

핵심 기능:

- TCP 서버 구동 및 장비(클라이언트) 연결 수용
- 초기 인증(0xFF) 및 Keep-Alive/Status Poll 유지
- 웹 UI 기반 개별 포트(1~4번) 전원 ON/OFF 제어 (OpCode 0x21)
- 전체 포트 일괄 ON/OFF 제어 (OpCode 0x22)
- 제어 이력 및 장애 이벤트 로깅

  1.2. 기술 스택 (Tech Stack)

- Run Environment: Node.js + pnpm workspace (monorepo)
- Backend: NestJS (HTTP API + TCP Socket Server)
- Frontend: React (Vite), TailwindCSS, shadcn/ui
- UI Theme: Strict Monochrome (Black/White, Red only for critical alerts)
- Database: MariaDB (Prisma ORM, snake_case columns)
- Protocol: Custom TCP/IP (Big-Endian, Fixed Header) — 모든 세부 동작은 `전원원격제어장치 통신 인터페이스 정의서 v2.1`을 기준으로 한다[file://전원원격제어장치_통신_인터페이스정의서_v2.1.pdf]

  1.3. 실행 & 환경 정리

- `pnpm install` (workspace 루트에서 단 한 번 실행)
- `pnpm dev` → server `start:dev` + web `dev` 를 동시에 실행 (concurrently)
- `.env` 필수 키
  ```
  DATABASE_URL="mysql://rcs_user:password@127.0.0.1:3306/rcs"
  TCP_SENDER_IP="10.10.10.10"
  STATUS_POLL_INTERVAL_MS=60000
  HTTP_PORT=3000
  TCP_PORT=32200
  ```
- Prisma DB 마이그레이션: `pnpm --filter server prisma migrate dev`

2. 상세 기획서 (Functional Specification)
   2.1. 데이터베이스 설계 (Prisma Schema, snake_case)

```ts
// schema.prisma 핵심 예시
model Device {
  deviceId        String       @id                @map("device_id")
  stationNumber   String       @unique            @map("station_number")
  ipAddress       String                           @map("ip_address")
  status          DeviceStatus @default(OFFLINE)  @map("status")
  statusBitmap    Int?                             @map("status_bitmap")
  lastConnectedAt DateTime?                        @map("last_connected_at")
  createdAt       DateTime     @default(now())     @map("created_at")
  updatedAt       DateTime     @updatedAt          @map("updated_at")
  ports           PowerPort[]
  logs            EventLog[]

  @@map("devices")
}

model PowerPort {
  id         Int     @id @default(autoincrement())
  deviceId   String              @map("device_id")
  portIndex  Int                 @map("port_index")
  isOn       Boolean @default(false) @map("is_on")
  voltageMv  Int?                @map("voltage_mv") // 10mV 단위값 환산
  currentMa  Int?                @map("current_ma") // 10mA 단위값 환산
  device     Device  @relation(fields: [deviceId], references: [deviceId])

  @@unique([deviceId, portIndex])
  @@map("power_ports")
}

model EventLog {
  id         Int        @id @default(autoincrement())
  deviceId   String                  @map("device_id")
  type       EventType               @map("type") // CONTROL, STATUS, EVENT_A1, EVENT_A2, EVENT_A3, EVENT_A4, RESET, FW_UPDATE
  message    String                  @map("message")
  rawPacket  String?                 @map("raw_packet")
  createdAt  DateTime    @default(now()) @map("created_at")
  device     Device      @relation(fields: [deviceId], references: [deviceId])

  @@map("event_logs")
}
```

2.2. 백엔드 로직 (NestJS)

- **TCP 서버 모듈 (Gateway)**

  - 포트: 32200 (장비는 클라이언트 역할)
  - 초기 플로우: 연결 → 서버가 `0xFF`(Device ID Req) 전송 → 장비 응답 → DB upsert
  - Keep-Alive: 장비가 `0x30` 전송 시 즉시 ACK(`0x06`) 회신, 응답이 없으면 장비가 최대 3회까지 재시도 후 세션을 종료한다[file://전원원격제어장치_통신_인테페이스정의서_v2.1.pdf]
  - Status Poll: 서버가 60초마다 `0x11` 요청 → 응답 패킷으로 전압/전류/비트맵 파싱 → Prisma 업데이트
  - PacketParser: Buffer 기반 Big-Endian 파싱/생성 헬퍼, 헤더 43B + Data 구조를 단일 책임으로 유지
  - NAK(`0x15 + ErrorCode`) 수신 시 원인 로그 + 예외 전파, ACK(`0x06`) 수신 시 제어 이력 업데이트

- **제어 서비스 (Control Service)**

  - 개별 제어 (`0x21`): [Port(1B), Status(1B)] → ACK 시 포트 상태 Sync, NAK 시 UI Toast + EventLog
  - 일괄 제어 (`0x22`): [Status(1B)] → 포트 전체 토글
  - 리셋 (`0x51`): Data 없음, 응답 ACK/NAK 필수 기록 → UI와 EventLog에 동기화[file://전원원격제어장치_통신_인테페이스정의서_v2.1.pdf]
  - 펌웨어 업데이트 (`0x52`): [파일 크기(4B) + 바이너리] 전송 → 응답 ACK/NAK 기록 및 대용량 전송 도중 청크 검증[file://전원원격제어장치_통신_인테페이스정의서_v2.1.pdf]
  - 모든 송수신 패킷은 Hex 문자열로 EventLog.raw_packet 에 저장

- **이벤트 수신 (Alarm/Event Service)**

  - `0xA1` AC 전원 OFF: [포트 번호(1B), 원인 코드(1B)] → UI 즉시 배지 업데이트 → EventLog type `EVENT_A1`
  - `0xA2` 온도 알람: [온도(2B, 0.1℃)] → 안전 임계치 초과 시 Critical Toast 전송
  - `0xA3` 전압 알람: [포트 번호(1B), 전압(2B, 10mV)] → 차트/로그 반영
  - `0xA4` 전류 알람: [포트 번호(1B), 전류(2B, 10mA)] → 과전류 이벤트 표기
  - 모든 이벤트는 재요청 없이 push-only 이므로, 중복 수신 대비 idempotent 저장이 필요하다[file://전원원격제어장치_통신_인테페이스정의서_v2.1.pdf]

    2.3. 프론트엔드 UI (React + shadcn/ui)

- Monochrome Dashboard (Grid)
  - Header: 시스템 상태, 현재 시간, 연결 장비 수, 마지막 Keep-Alive 시간
  - Device Card: Device ID, IP, Last Connected, Status Badge
  - Control Panel: 4개의 Port Card (Switch, Voltage/Current Badge, ACK/NAK Toast)
  - Global Actions: “전체 켜기/끄기” 버튼 (variant="outline")
  - Log Viewer: shadcn Table로 제어/알람/장애 로그 표시
- 피드백은 Sonner Toast(`toast.success/error`)만 사용, 강조 색상은 흑/백/적만 허용.

  2.4. 운영 & 테스트 체크리스트

- Prisma 마이그레이션과 Seed 스크립트는 모든 환경(Dev/Staging/Prod)에서 동일하게 동작해야 함
- 단위 테스트: PacketParser (헤더/Big-Endian), DeviceSync 서비스 (포트 upsert), React Control Panel (렌더/상태 토글)
- 통합 테스트: TCP Gateway Keep-Alive 시나리오(3회 재시도), 이벤트 수신 파이프라인, HTTP `/health` 엔드포인트
- 모니터링: EventLog raw_packet + last_connected_at 컬럼을 기반으로 Grafana/Alertmanager 연동
- 배포 후 점검: `pnpm dev` 동시 실행 → `pnpm --filter server test` → `pnpm --filter web build`

3. 프로토콜 구현 상세 가이드

- Header Structure: Sender IP(16, `0x2D` padding) + Dest IP(16) + Ctrl Kind("RC") + Station Number(4, Echo) + Total Length(4, OpCode+Data) + OpCode(1) + Data(N)[file://전원원격제어장치_통신_인테페이스정의서_v2.1.pdf]
- Keep-Alive: 장비 → `0x30`, 서버 → `ACK(0x06)` + 최근 Status Poll 예약, 미응답 시 장비 3회 재시도 후 세션 종료[file://전원원격제어장치_통신_인테페이스정의서_v2.1.pdf]
- Status Response(`0x11`):
  - Data = [StatusBitmap(1)] + repeat(Voltage(2) + Current(2))
  - Voltage unit 10mV, Current unit 10mA → DB 저장 시 각각 `*10` 환산
- Individual Control(`0x21`): Data = [Port(1), OnOff(1)], 성공 시 Status Poll 즉시 실행
- Batch Control(`0x22`): Data = [OnOff(1)], 전 포트를 동일 상태로 강제
- Reset(`0x51`): Data 없음, 서버↔장비 동일 OpCode 사용, 응답 ACK/NAK 필수 → 실패 시 인시던트 생성[file://전원원격제어장치_통신_인테페이스정의서_v2.1.pdf]
- Firmware Update(`0x52`): Data = [FileLength(4B) + Binary], 4GB 이하 payload, 완료 시 ACK/NAK 전송[file://전원원격제어장치_통신_인테페이스정의서_v2.1.pdf]
- Event Opcodes(`0xA1`~`0xA4`):
  - `0xA1` AC 전원 OFF: [Port(1), Reason(1)] → Reason 0x00 KeyPad, 0x01 과전류, 0x02 통신이상, 0xFF Unknown
  - `0xA2` 온도 알람: [Temperature(2, 0.1℃)]
  - `0xA3` 전압 알람: [Port(1), Voltage(2, 10mV)]
  - `0xA4` 전류 알람: [Port(1), Current(2, 10mA)]
  - 모든 이벤트는 수신 즉시 로그 및 실시간 알림을 발생시킨다[file://전원원격제어장치_통신_인테페이스정의서_v2.1.pdf]
- Error Handling: `NAK = 0x15 + ErrorCode`, 수신 시 EventLog + UI Toast + 재시도 전략 적용 (최대 3회, 지수적 Backoff)
